<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Symbol Editor</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            color: #222;
            min-height: 100vh;
        }
        
        h1 {
            margin: 0 0 24px 0;
            font-size: 22px;
            color: #111;
            font-weight: 900;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }
        
        .container {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 320px;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
            align-items: stretch;
        }

        .workspace-grid {
            display: grid;
            grid-template-columns: 240px minmax(500px, 1fr);
            gap: 20px;
            align-content: start;
        }

        .components-panel {
            grid-column: 1;
            grid-row: 1;
            min-height: 600px;
            max-height: 600px;
        }

        .canvas-panel {
            grid-column: 2;
            grid-row: 1;
        }
        
        .panel {
            background: #fff;
            border-radius: 0;
            padding: 16px;
            border: 1px solid #d0d0d0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }
        
        .panel h2 {
            margin: 0 0 15px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #666;
            font-weight: normal;
        }
        
        /* Component List */
        .component-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .component-item {
            padding: 10px;
            background: #fafafa;
            border-radius: 0;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid #e0e0e0;
        }
        
        .component-item:hover {
            background: #f0f0f0;
        }
        
        .component-item.selected {
            background: #e8e8e8;
            border: 1px solid #333;
        }
        
        .component-item svg {
            width: 40px;
            height: 30px;
            flex-shrink: 0;
        }
        
        .component-item svg path,
        .component-item svg circle,
        .component-item svg polygon,
        .component-item svg ellipse {
            stroke: #333 !important;
            fill: none !important;
        }
        
        .component-item svg polygon {
            fill: #333 !important;
        }
        
        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .btn .material-symbols-outlined {
            font-size: 18px;
        }
        
        .btn-icon {
            padding: 8px;
            min-width: 36px;
        }
        
        .btn-primary {
            background: #222;
            color: #fff;
            border: 1px solid #222;
            font-weight: 500;
        }
        
        .btn-primary:hover {
            background: #444;
            border-color: #444;
        }
        
        .btn-secondary {
            background: #fff;
            color: #333;
            border: 1px solid #aaa;
            font-weight: 500;
        }
        
        .btn-secondary:hover {
            background: #f8f8f8;
            border-color: #888;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        /* Canvas Area */
        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-height: 600px;
            max-height: 600px;
        }
        
        .toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .toolbar .separator {
            width: 1px;
            height: 24px;
            background: #ccc;
            margin: 0 8px;
        }
        
        .toolbar label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .toolbar input[type="number"] {
            width: 48px;
            padding: 4px 8px;
            border: 1px solid #999;
            border-radius: 0;
            background: #fff;
            color: #222;
        }

        .zoom-indicator {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .canvas-layout {
            display: flex;
            gap: 16px;
            align-items: stretch;
        }
        .canvas-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            order: 1;
        }
        .canvas-wrapper {
            flex: 1;
            background: #fff;
            border-radius: 0;
            overflow: hidden;
            position: relative;
            min-height: 500px;
            max-height: 500px;
            border: 1px solid #d0d0d0;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.04);
            position: relative;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: block;
        }
        
        .canvas-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 10px;
            color: #999;
            pointer-events: none;
            font-family: monospace;
            display: flex;
            gap: 12px;
            text-transform: uppercase;
        }

        .label-preview-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 220px;
            flex-shrink: 0;
            order: 2;
            height: 100%;
            min-height: 0;
        }
        
        .label-preview {
            border: 1px solid #d8d8d8;
            background: transparent;
            padding: 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .label-preview-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .label-preview canvas {
            width: 100%;
            height: 100%;
            border: none;
            background: #fff;
            display: block;
            flex: 1;
        }
        
        .label-chip {
            font-size: 9px;
            color: #999;
            border: 1px solid #ccc;
            padding: 1px 4px;
            border-radius: 2px;
        }
        
        /* Properties Panel */
        .properties {
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            align-self: stretch;
            height: 100%;
        }
        
        .prop-group {
            background: #fafafa;
            border-radius: 0;
            padding: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .prop-group h3 {
            margin: 0 0 10px 0;
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: normal;
        }
        
        .prop-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .prop-row:last-child {
            margin-bottom: 0;
        }
        
        .prop-row label {
            font-size: 11px;
            color: #666;
            min-width: 70px;
        }
        
        .prop-row input[type="text"],
        .prop-row input[type="number"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #aaa;
            border-radius: 0;
            background: #fff;
            color: #222;
            font-size: 12px;
            transition: border-color 0.2s;
        }

        .prop-row input[type="text"]::placeholder,
        .prop-row input[type="number"]::placeholder {
            color: #c3c3c3;
        }
        
        .prop-row input[type="text"]:focus,
        .prop-row input[type="number"]:focus {
            outline: none;
            border-color: #333;
        }
        
        .prop-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        
        .pin-list, .element-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .pin-item, .element-item {
            background: #fff;
            padding: 8px;
            border-radius: 0;
            font-size: 11px;
            border: 1px solid #e0e0e0;
        }
        
        .pin-item.selected, .element-item.selected {
            border: 1px solid #333;
            background: #f5f5f5;
        }
        
        .pin-header, .element-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .pin-coords, .element-coords {
            display: flex;
            gap: 8px;
        }
        
        .pin-coords input, .element-coords input {
            width: 50px;
            padding: 4px;
            border: 1px solid #999;
            border-radius: 0;
            background: #fff;
            color: #222;
            font-size: 11px;
        }

        .label-coords {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .label-coords input {
            width: 60px;
        }
        
        .small-btn {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        /* JSON Output */
        .json-output {
            grid-column: 1 / span 2;
            margin-top: 0;
        }
        
        .json-output h2 {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #jsonOutput {
            width: 100%;
            height: 420px;
            background: #fafafa;
            border: 1px solid #999;
            border-radius: 0;
            color: #222;
            font-family: 'Courier New', Courier, monospace;
            font-size: 11px;
            padding: 10px;
            resize: vertical;
        }
        
        /* Mode indicators */
        .mode-indicator {
            padding: 4px 12px;
            border-radius: 0;
            font-size: 10px;
            font-weight: normal;
            border: 1px solid #333;
            letter-spacing: 1px;
        }
        
        .mode-select { background: #fff; color: #333; }
        .mode-line { background: #333; color: #fff; }
        .mode-circle { background: #333; color: #fff; }
        .mode-arc { background: #333; color: #fff; }
        .mode-polygon { background: #333; color: #fff; }
        .mode-polyline { background: #333; color: #fff; }
        .mode-pin { background: #333; color: #fff; }
        
        /* File import */
        #fileInput {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Circuit Symbol Editor</h1>
    
    <div class="container">
        <div class="workspace-grid">
            <!-- Left Panel: Component List -->
            <div class="panel components-panel">
                <h2>Components</h2>
                <div class="component-list" id="componentList"></div>
                <div class="btn-group">
                    <button class="btn btn-primary btn-icon" onclick="newComponent()" title="New Component">
                        <span class="material-symbols-outlined">add</span>
                    </button>
                    <button class="btn btn-secondary btn-icon" onclick="duplicateComponent()" title="Duplicate Component">
                        <span class="material-symbols-outlined">content_copy</span>
                    </button>
                    <button class="btn btn-danger btn-icon" onclick="deleteComponent()" title="Delete Component">
                        <span class="material-symbols-outlined">delete</span>
                    </button>
                </div>
                <div class="btn-group">
                    <input type="file" id="fileInput" accept=".json" onchange="loadFromFile(event)">
                    <button class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">Load JSON</button>
                </div>
            </div>
            
            <!-- Center: Canvas -->
            <div class="panel canvas-container canvas-panel">
            <div class="toolbar">
                <button class="btn btn-secondary btn-icon" onclick="setMode('select')" id="btn-select" title="Select">
                    <span class="material-symbols-outlined">arrow_selector_tool</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="setMode('line')" id="btn-line" title="Line">
                    <span class="material-symbols-outlined">diagonal_line</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="setMode('circle')" id="btn-circle" title="Circle">
                    <span class="material-symbols-outlined">circle</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="setMode('arc')" id="btn-arc" title="Arc">
                    <span class="material-symbols-outlined">line_curve</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="setMode('polygon')" id="btn-polygon" title="Polygon">
                    <span class="material-symbols-outlined">pentagon</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="setMode('polyline')" id="btn-polyline" title="Polyline">
                    <span class="material-symbols-outlined">polyline</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="setMode('pin')" id="btn-pin" title="Pin">
                    <span class="material-symbols-outlined">line_end_circle</span>
                </button>
                <div class="separator"></div>
                <button class="btn btn-secondary btn-icon" onclick="deleteSelected()" title="Delete Selected">
                    <span class="material-symbols-outlined">backspace</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="clearDrawing()" title="Clear All">
                    <span class="material-symbols-outlined">delete_sweep</span>
                </button>
                <div class="separator"></div>
                <label>Stroke:</label>
                <input type="number" id="strokeWidth" value="4" min="1" max="10" onchange="updateSelectedStroke()">
                <input type="checkbox" id="filled" style="margin-left: 10px;">
                <label for="filled">Fill</label>
                <div class="separator"></div>
                <label>Grid:</label>
                <input type="number" id="gridSize" value="5" min="1" max="20" onchange="redraw()">
                <input type="checkbox" id="snapToGrid" checked style="margin-left: 10px;">
                <label for="snapToGrid" style="min-width: auto;">Snap</label>
            </div>
            <div class="canvas-layout">
                <div class="label-preview-section">
                    <div class="label-preview">
                        <div class="label-preview-title">
                            <span>Labels 0° / 180°</span>
                            <span class="label-chip">View Only</span>
                        </div>
                        <canvas id="labelPreview0"></canvas>
                    </div>
                    <div class="label-preview">
                        <div class="label-preview-title">
                            <span>Labels 90° / 270°</span>
                            <span class="label-chip">View Only</span>
                        </div>
                        <canvas id="labelPreview90"></canvas>
                    </div>
                </div>
                <div class="canvas-main">
                    <div class="canvas-wrapper">
                        <canvas id="canvas"></canvas>
                        <div class="canvas-info" id="canvasInfo">x: 0, y: 0</div>
                    </div>
                </div>
            </div>
        </div>

            <!-- JSON Output -->
            <div class="panel json-output">
                <h2>
                    JSON Output
                    <button class="btn btn-secondary" onclick="copyJSON()">Copy to Clipboard</button>
                </h2>
                <textarea id="jsonOutput" readonly></textarea>
            </div>
        </div>

        <!-- Right Panel: Properties -->
        <div class="panel properties">
            <div class="prop-group">
                <h3>Component Info</h3>
                <div class="prop-row">
                    <label>ID:</label>
                    <input type="text" id="compId" placeholder="resistor">
                </div>
                <div class="prop-row">
                    <label>Name:</label>
                    <input type="text" id="compName" placeholder="Resistor">
                </div>
                <div class="prop-row">
                    <label>Prefix:</label>
                    <input type="text" id="compPrefix" placeholder="R" style="width: 50px;">
                    <input type="checkbox" id="compAutoInc" checked>
                    <label for="compAutoInc" style="min-width: auto;">Auto #</label>
                </div>
                <div class="prop-row">
                    <label>Default:</label>
                    <input type="text" id="compDefault" placeholder="1k">
                </div>
                <div class="prop-row">
                    <label>Width:</label>
                    <input type="number" id="compWidth" value="80" min="20" max="200" onchange="resizeCanvas()">
                </div>
                <div class="prop-row">
                    <label>Height:</label>
                    <input type="number" id="compHeight" value="40" min="20" max="200" onchange="resizeCanvas()">
                </div>
            </div>
            
            <div class="prop-group">
                <h3>SPICE Model (optional)</h3>
                <div class="prop-row">
                    <label>Model:</label>
                    <input type="text" id="modelName" placeholder="D1N4148">
                </div>
                <div class="prop-row">
                    <label>Definition:</label>
                    <input type="text" id="modelDef" placeholder=".model D1N4148 D(...)">
                </div>
            </div>
            
            <div class="prop-group">
                <h3>Pins</h3>
                <div class="pin-list" id="pinList"></div>
                <button class="btn btn-secondary small-btn" style="margin-top: 8px;" onclick="addPinManual()">+ Add Pin</button>
            </div>

            <div class="prop-group">
                <h3>Label Placement (0° / 180°)</h3>
                <div class="prop-row">
                    <label>Designator:</label>
                    <div class="label-coords">
                        <input type="number" id="designatorLabel0X" placeholder="x">
                        <input type="number" id="designatorLabel0Y" placeholder="y">
                    </div>
                </div>
                <div class="prop-row">
                    <label>Value:</label>
                    <div class="label-coords">
                        <input type="number" id="valueLabel0X" placeholder="x">
                        <input type="number" id="valueLabel0Y" placeholder="y">
                    </div>
                </div>
            </div>

            <div class="prop-group">
                <h3>Label Placement (90° / 270°)</h3>
                <div class="prop-row">
                    <label>Designator:</label>
                    <div class="label-coords">
                        <input type="number" id="designatorLabel90X" placeholder="x">
                        <input type="number" id="designatorLabel90Y" placeholder="y">
                    </div>
                </div>
                <div class="prop-row">
                    <label>Value:</label>
                    <div class="label-coords">
                        <input type="number" id="valueLabel90X" placeholder="x">
                        <input type="number" id="valueLabel90Y" placeholder="y">
                    </div>
                </div>
            </div>
            
            <div class="prop-group">
                <h3>Drawing Elements</h3>
                <div class="element-list" id="elementList"></div>
            </div>
            
            <button class="btn btn-primary" onclick="updateComponent()" style="width: 100%;">Save Component</button>
        </div>
    </div>
    
    

    <script>
        // State
        let components = {};
        let currentComponentId = null;
        let mode = 'select';
        let elements = []; // Drawing elements for current component
        let pins = []; // Pins for current component
        let selectedElement = null;
        let selectedElements = new Set(); // Multiple selected elements
        let isDrawing = false;
        let isDragging = false;
        let isSelecting = false; // Drag-selecting multiple elements
        let dragStart = null;
        let drawStart = null;
        let selectionRect = null; // { x1, y1, x2, y2 } in component coords
        let polygonPoints = [];
        let polylinePoints = [];
        let arcStage = 0; // 0: idle, 1: center chosen, 2: start/radius chosen
        let arcCenter = null;
        let arcRadius = null;
        let arcStartAngle = null;
        let arcPreviewPoint = null;
        let editingVertex = null; // { elementIndex, vertexIndex or 'start'/'end' }
        let undoStack = []; // Stack of actions for undo
        let originalElementState = null; // Element state at start of drag
        let originalElementStates = new Map(); // Map of element states for multi-drag
        let draggingPinIndex = null;
        let pinDragOffset = null;
        let zoomLevel = 3;
        const MIN_ZOOM = 1;
        const MAX_ZOOM = 10;
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const zoomIndicator = document.createElement('span');
        zoomIndicator.className = 'zoom-indicator';
        const coordIndicator = document.createElement('span');
        coordIndicator.className = 'zoom-indicator';
        coordIndicator.textContent = 'X: 0.00, Y: 0.00';
        const labelPreviewCanvases = [
            { canvas: document.getElementById('labelPreview0'), orientation: 0 },
            { canvas: document.getElementById('labelPreview90'), orientation: 90 }
        ].map(entry => {
            const previewCanvas = entry.canvas;
            const preview = {
                ...entry,
                canvas: previewCanvas,
                ctx: previewCanvas ? previewCanvas.getContext('2d') : null,
                markerTargets: [],
                transform: null
            };
            if (previewCanvas) {
                previewCanvas.style.touchAction = 'none';
                previewCanvas.addEventListener('pointerdown', (event) => handleLabelPreviewPointerDown(preview, event));
                previewCanvas.addEventListener('pointermove', (event) => handleLabelPreviewPointerMove(preview, event));
                previewCanvas.addEventListener('pointerup', (event) => handleLabelPreviewPointerUp(preview, event));
                previewCanvas.addEventListener('pointerleave', (event) => handleLabelPreviewPointerUp(preview, event));
                previewCanvas.addEventListener('pointercancel', (event) => handleLabelPreviewPointerUp(preview, event));
            }
            return preview;
        });
        let labelPreviewDirty = false;
        let labelDragState = null;

        function clampZoom(value) {
            return Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, value));
        }

        function updateZoomIndicator() {
            if (!zoomIndicator) return;
            zoomIndicator.textContent = 'Zoom: ' + zoomLevel.toFixed(1) + 'x';
        }

        function setZoomLevel(value, options = {}) {
            const clamped = clampZoom(value);
            if (!options.force && Math.abs(clamped - zoomLevel) < 0.001) return;
            zoomLevel = clamped;
            updateZoomIndicator();
            redraw();
        }

        function onCanvasWheel(event) {
            const pinchGesture = event.ctrlKey || event.metaKey;
            const trackpadScrollGesture = !pinchGesture && event.deltaMode === 0;
            if (!pinchGesture && !trackpadScrollGesture) return;
            event.preventDefault();
            const multiplier = pinchGesture ? 0.01 : 0.0025;
            const increment = -event.deltaY * multiplier;
            if (increment === 0) return;
            setZoomLevel(zoomLevel + increment);
        }
        
        // Initialize
        function init() {
            resizeCanvas();
            resizePreviewCanvases();
            window.addEventListener('resize', () => {
                resizeCanvas();
            });
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('dblclick', onDoubleClick);
            canvas.addEventListener('wheel', onCanvasWheel, { passive: false });
            const info = document.getElementById('canvasInfo');
            if (info) {
                info.innerHTML = '';
                info.appendChild(zoomIndicator);
                info.appendChild(coordIndicator);
            }
            
            // Keyboard shortcuts
            window.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'Escape') {
                    if (mode === 'arc' && arcStage > 0) {
                        resetArcConstruction();
                        redraw();
                    }
                }
            });
            
            // Load default components
            attachLabelInputListeners();
            window.addEventListener('mouseup', () => flushLabelPreviewUpdates());
            loadDefaultComponents();
            requestLabelPreviewUpdate({ immediate: true });
            updateZoomIndicator();
        }
        
        function loadDefaultComponents() {
            // Start with a minimal set of example components
            components = {
                "resistor": {
                    "name": "Resistor",
                    "description": "Standard two-pin resistor symbol",
                    "defaultValue": "1k",
                    "designator": { "prefix": "R", "autoIncrement": true },
                    "size": { "width": 80, "height": 40 },
                    "pins": [
                        { "id": "1", "name": "A", "position": { "x": 0, "y": 20 } },
                        { "id": "2", "name": "B", "position": { "x": 80, "y": 20 } }
                    ],
                    "labels": {
                        "designator": [{ "x": 40, "y": -12 }, { "x": -12, "y": 20 }],
                        "value": [{ "x": 40, "y": 52 }, { "x": 92, "y": 20 }]
                    },
                    "svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 120 40\"><path fill=\"none\" stroke=\"#000000\" stroke-width=\"4\" stroke-linejoin=\"round\" stroke-linecap=\"round\" d=\"M 0 20 L 35 20 L 40 10 L 50 30 L 60 10 L 70 30 L 80 10 L 90 30 L 95 20 L 120 20\"/></svg>"
                },
                "capacitor": {
                    "name": "Capacitor",
                    "description": "Parallel plate capacitor symbol",
                    "defaultValue": "1uF",
                    "designator": { "prefix": "C", "autoIncrement": true },
                    "size": { "width": 80, "height": 40 },
                    "pins": [
                        { "id": "1", "name": "A", "position": { "x": 0, "y": 20 } },
                        { "id": "2", "name": "B", "position": { "x": 80, "y": 20 } }
                    ],
                    "labels": {
                        "designator": [{ "x": 40, "y": -12 }, { "x": -12, "y": 20 }],
                        "value": [{ "x": 40, "y": 52 }, { "x": 92, "y": 20 }]
                    },
                    "svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 120 40\"><g fill=\"none\" stroke=\"#000000\" stroke-width=\"4\" stroke-linejoin=\"round\" stroke-linecap=\"round\"><path d=\"M 0 20 L 53.333 20\"/><path d=\"M 53.306 3.708 L 53.361 38.708\"/><path d=\"M 66.639 3.696 L 66.694 38.696\"/><path d=\"M 66.667 20 L 120 20\"/></g></svg>"
                },
                "ground": {
                    "name": "Ground",
                    "description": "Reference ground symbol",
                    "defaultValue": "",
                    "designator": { "prefix": "GND", "autoIncrement": false },
                    "size": { "width": 40, "height": 40 },
                    "isGround": true,
                    "pins": [{ "id": "1", "name": "GND", "position": { "x": 20, "y": 0 } }],
                    "labels": {
                        "designator": [{ "x": 20, "y": -12 }, { "x": -12, "y": 20 }],
                        "value": [{ "x": 20, "y": 52 }, { "x": 52, "y": 20 }]
                    },
                    "svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 80 80\"><g fill=\"none\" stroke=\"#000000\" stroke-width=\"2.7596\" stroke-linecap=\"round\"><path d=\"M 40.081 4 L 40.081 41.155\"/><path d=\"M 10.358 41.155 L 69.804 41.155\"/><path d=\"M 19.926 59.151 L 60.235 59.151\"/><path d=\"M 30.902 76 L 49.259 76\"/></g></svg>"
                }
            };
            
            updateComponentList();
            updateJSON();
            const defaultWidth = parseInt(document.getElementById('compWidth').value, 10) || 80;
            const defaultHeight = parseInt(document.getElementById('compHeight').value, 10) || 40;
            setLabelInputs(getDefaultLabelPositions(defaultWidth, defaultHeight), defaultWidth, defaultHeight);
        }
        
        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            // Get the actual content dimensions (excluding borders and padding)
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            redraw();
        }
        
        // Mode handling
        function setMode(newMode) {
            mode = newMode;
            polygonPoints = [];
            polylinePoints = [];
            resetArcConstruction();
            
            // Update button states
            document.querySelectorAll('.toolbar .btn').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            const btn = document.getElementById('btn-' + mode);
            if (btn) {
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
            }
            
            // Update indicator
            const indicator = document.getElementById('modeIndicator');
            indicator.textContent = mode.toUpperCase();
            indicator.className = 'mode-indicator mode-' + mode;
            
            redraw();
        }

        function resetArcConstruction() {
            arcStage = 0;
            arcCenter = null;
            arcRadius = null;
            arcStartAngle = null;
            arcPreviewPoint = null;
        }
        
        // Canvas coordinate helpers
        function getCanvasOffset() {
            const zoom = zoomLevel;
            const compWidth = parseInt(document.getElementById('compWidth').value) || 80;
            const compHeight = parseInt(document.getElementById('compHeight').value) || 40;
            
            // Center the component with some padding
            const offsetX = (canvas.width - compWidth * zoom) / 2;
            const offsetY = (canvas.height - compHeight * zoom) / 2;
            
            return { x: offsetX, y: offsetY, zoom };
        }
        
        function canvasToComponent(cx, cy, options = {}) {
            const { x: offsetX, y: offsetY, zoom } = getCanvasOffset();
            const grid = parseInt(document.getElementById('gridSize').value);
            const snapSetting = options.snap !== undefined ? options.snap : document.getElementById('snapToGrid').checked;
            
            let compX = (cx - offsetX) / zoom;
            let compY = (cy - offsetY) / zoom;
            
            // Snap to grid if enabled
            if (snapSetting) {
                compX = Math.round(compX / grid) * grid;
                compY = Math.round(compY / grid) * grid;
            }
            
            return { x: compX, y: compY };
        }
        
        function componentToCanvas(compX, compY) {
            const { x: offsetX, y: offsetY, zoom } = getCanvasOffset();
            return {
                x: compX * zoom + offsetX,
                y: compY * zoom + offsetY
            };
        }

        function requestLabelPreviewUpdate(options = {}) {
            const immediate = options.immediate || false;
            if (immediate) {
                labelPreviewDirty = false;
                updateLabelPreviews();
                return;
            }
            const shouldDefer = isDrawing || isDragging || isSelecting || (mode === 'arc' && arcStage > 0);
            if (shouldDefer) {
                labelPreviewDirty = true;
                return;
            }
            labelPreviewDirty = false;
            updateLabelPreviews();
        }

        function flushLabelPreviewUpdates() {
            if (!labelPreviewDirty) return;
            labelPreviewDirty = false;
            updateLabelPreviews();
        }

        function attachLabelInputListeners() {
            const ids = [
                'designatorLabel0X', 'designatorLabel0Y',
                'valueLabel0X', 'valueLabel0Y',
                'designatorLabel90X', 'designatorLabel90Y',
                'valueLabel90X', 'valueLabel90Y'
            ];
            ids.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    const trigger = () => requestLabelPreviewUpdate({ immediate: true });
                    input.addEventListener('input', trigger);
                    input.addEventListener('change', trigger);
                }
            });
            ['compPrefix', 'compDefault'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    const trigger = () => requestLabelPreviewUpdate({ immediate: true });
                    input.addEventListener('input', trigger);
                    input.addEventListener('change', trigger);
                }
            });
        }

        function resizePreviewCanvases() {
            labelPreviewCanvases.forEach(({ canvas }) => {
                if (!canvas) return;
                const rect = canvas.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return;
                if (canvas.width !== rect.width || canvas.height !== rect.height) {
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                }
            });
        }

        function updateLabelPreviews() {
            resizePreviewCanvases();
            const compWidth = parseInt(document.getElementById('compWidth').value, 10) || 80;
            const compHeight = parseInt(document.getElementById('compHeight').value, 10) || 40;
            const labels = readLabelInputs(compWidth, compHeight);
            labelPreviewCanvases.forEach(preview => {
                drawLabelPreview(preview, labels, compWidth, compHeight);
            });
        }

        function drawLabelPreview(preview, labels, compWidth, compHeight) {
            const { canvas, ctx, orientation } = preview;
            if (!canvas || !ctx || canvas.width === 0 || canvas.height === 0) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const angle = orientation === 90 ? Math.PI / 2 : 0;
            const designator = orientation === 0 ? labels.designator[0] : labels.designator[1];
            const value = orientation === 0 ? labels.value[0] : labels.value[1];
            const extraPoints = [designator, value]
                .filter(Boolean)
                .map(point => ({ point, rotate: false }));
            const transform = createPreviewTransform(
                compWidth,
                compHeight,
                angle,
                canvas.width,
                canvas.height,
                extraPoints
            );
            if (!transform) {
                preview.transform = null;
                preview.markerTargets = [];
                return;
            }

            preview.transform = transform;
            preview.markerTargets = [];

            // Draw component boundary
            ctx.save();
            ctx.strokeStyle = '#c2c2c2';
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(
                transform.offsetX,
                transform.offsetY,
                transform.bounds.width * transform.scale,
                transform.bounds.height * transform.scale
            );
            ctx.restore();

            drawPreviewOrigin(ctx, transform);
            drawPreviewElements(ctx, transform);
            drawPreviewPins(ctx, transform);

            const prefixInput = document.getElementById('compPrefix');
            const defaultInput = document.getElementById('compDefault');
            const prefixText = (prefixInput?.value || '').trim() || 'DES';
            const defaultText = (defaultInput?.value || '').trim() || 'VAL';
            const orientationIndex = orientation === 0 ? 0 : 1;
            drawLabelMarker(ctx, designator, transform, '#1e88e5', prefixText, {
                preview,
                labelType: 'designator',
                orientationIndex
            });
            drawLabelMarker(ctx, value, transform, '#43a047', defaultText, {
                preview,
                labelType: 'value',
                orientationIndex
            });
        }

        function drawPreviewOrigin(ctx, transform) {
            const origin = projectPointForPreview({ x: 0, y: 0 }, transform);
            ctx.save();
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawPreviewElements(ctx, transform) {
            ctx.save();
            ctx.strokeStyle = '#444';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            elements.forEach(el => {
                const strokeWidth = Math.max(1, ((el.strokeWidth || 4) * transform.scale) / 3);
                ctx.lineWidth = strokeWidth;
                if (el.type === 'line') {
                    const start = projectPointForPreview({ x: el.x1, y: el.y1 }, transform);
                    const end = projectPointForPreview({ x: el.x2, y: el.y2 }, transform);
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                } else if (el.type === 'circle') {
                    const center = projectPointForPreview({ x: el.cx, y: el.cy }, transform);
                    const radius = Math.max(1, el.r * transform.scale);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                    if (el.filled) {
                        ctx.fillStyle = '#000';
                        ctx.fill();
                    }
                    ctx.stroke();
                } else if (el.type === 'arc') {
                    const center = projectPointForPreview({ x: el.cx, y: el.cy }, transform);
                    const radius = Math.max(1, el.r * transform.scale);
                    ctx.beginPath();
                    ctx.arc(
                        center.x,
                        center.y,
                        radius,
                        el.startAngle + transform.angle,
                        el.endAngle + transform.angle
                    );
                    ctx.stroke();
                } else if (el.type === 'polygon' && el.points) {
                    const pts = el.points.map(pt => projectPointForPreview(pt, transform));
                    if (pts.length) {
                        ctx.beginPath();
                        ctx.moveTo(pts[0].x, pts[0].y);
                        pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                        ctx.closePath();
                        if (el.filled) {
                            ctx.fillStyle = '#000';
                            ctx.fill();
                        }
                        ctx.stroke();
                    }
                } else if (el.type === 'polyline' && el.points) {
                    const pts = el.points.map(pt => projectPointForPreview(pt, transform));
                    if (pts.length) {
                        ctx.beginPath();
                        ctx.moveTo(pts[0].x, pts[0].y);
                        pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                        ctx.stroke();
                    }
                }
            });
            ctx.restore();
        }

        function drawPreviewPins(ctx, transform) {
            ctx.save();
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            pins.forEach(pin => {
                const pos = projectPointForPreview(pin.position, transform);
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillText(pin.id, pos.x, pos.y);
            });
            ctx.restore();
        }

        function drawLabelMarker(ctx, point, transform, color, label, options = {}) {
            if (!point) return;
            const projected = projectPointForPreview(point, transform, false);
            ctx.save();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(projected.x, projected.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = '9px monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, projected.x + 6, projected.y);
            ctx.restore();
            if (options.preview && options.preview.markerTargets) {
                options.preview.markerTargets.push({
                    type: options.labelType,
                    orientationIndex: options.orientationIndex,
                    canvasPosition: { x: projected.x, y: projected.y }
                });
            }
        }

        const LABEL_MARKER_HIT_RADIUS = 10;

        function getPreviewCanvasPoint(canvasElement, event) {
            if (!canvasElement) return null;
            const rect = canvasElement.getBoundingClientRect();
            const scaleX = canvasElement.width / rect.width;
            const scaleY = canvasElement.height / rect.height;
            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        function previewCanvasPointToComponent(preview, point) {
            if (!preview || !preview.transform || !point) return null;
            const transform = preview.transform;
            if (!transform.scale) return null;
            const normalizedX = (point.x - transform.offsetX) / transform.scale;
            const normalizedY = (point.y - transform.offsetY) / transform.scale;
            return {
                x: Math.round(normalizedX + transform.bounds.minX),
                y: Math.round(normalizedY + transform.bounds.minY)
            };
        }

        function setLabelPositionFromPreview(labelType, orientationIndex, position) {
            if (!position) return;
            const prefix = labelType === 'value' ? 'valueLabel' : 'designatorLabel';
            const suffix = orientationIndex === 0 ? '0' : '90';
            const xInput = document.getElementById(prefix + suffix + 'X');
            const yInput = document.getElementById(prefix + suffix + 'Y');
            const roundedX = Math.round(position.x);
            const roundedY = Math.round(position.y);
            if (xInput) xInput.value = roundedX;
            if (yInput) yInput.value = roundedY;
        }

        function updateLabelPositionFromCanvasPoint(preview, dragState, canvasPoint) {
            if (!dragState) return;
            const componentPoint = previewCanvasPointToComponent(preview, canvasPoint);
            if (!componentPoint) return;
            setLabelPositionFromPreview(dragState.labelType, dragState.orientationIndex, componentPoint);
            requestLabelPreviewUpdate({ immediate: true });
        }

        function handleLabelPreviewPointerDown(preview, event) {
            if (!preview?.canvas || !preview.markerTargets?.length) return;
            const canvasPoint = getPreviewCanvasPoint(preview.canvas, event);
            if (!canvasPoint) return;
            const hit = preview.markerTargets.find(target => {
                const dx = canvasPoint.x - target.canvasPosition.x;
                const dy = canvasPoint.y - target.canvasPosition.y;
                return Math.hypot(dx, dy) <= LABEL_MARKER_HIT_RADIUS;
            });
            if (!hit) return;
            event.preventDefault();
            labelDragState = {
                preview,
                pointerId: event.pointerId,
                labelType: hit.type,
                orientationIndex: hit.orientationIndex
            };
            preview.canvas.setPointerCapture(event.pointerId);
            updateLabelPositionFromCanvasPoint(preview, labelDragState, canvasPoint);
        }

        function handleLabelPreviewPointerMove(preview, event) {
            if (!labelDragState || labelDragState.preview !== preview || labelDragState.pointerId !== event.pointerId) return;
            event.preventDefault();
            const canvasPoint = getPreviewCanvasPoint(preview.canvas, event);
            if (!canvasPoint) return;
            updateLabelPositionFromCanvasPoint(preview, labelDragState, canvasPoint);
        }

        function handleLabelPreviewPointerUp(preview, event) {
            if (!labelDragState || labelDragState.preview !== preview || labelDragState.pointerId !== event.pointerId) return;
            if (preview.canvas?.hasPointerCapture?.(event.pointerId)) {
                preview.canvas.releasePointerCapture(event.pointerId);
            }
            event.preventDefault();
            labelDragState = null;
        }

        function createPreviewTransform(width, height, angle, canvasWidth, canvasHeight, extraPoints = []) {
            if (!width || !height || !canvasWidth || !canvasHeight) return null;
            const bounds = getRotatedBounds(width, height, angle, extraPoints);
            const padding = 12;
            const usableWidth = Math.max(canvasWidth - padding * 2, 10);
            const usableHeight = Math.max(canvasHeight - padding * 2, 10);
            const scale = Math.min(
                usableWidth / (bounds.width || 1),
                usableHeight / (bounds.height || 1)
            );
            const offsetX = (canvasWidth - bounds.width * scale) / 2;
            const offsetY = (canvasHeight - bounds.height * scale) / 2;
            return { angle, width, height, bounds, scale, offsetX, offsetY };
        }

        function getRotatedBounds(width, height, angle, extraPoints = []) {
            const baseCorners = [
                { x: 0, y: 0 },
                { x: width, y: 0 },
                { x: width, y: height },
                { x: 0, y: height }
            ].map(pt => angle === 0 ? pt : rotatePointAroundCenter(pt, angle, width, height));
            const xs = baseCorners.map(p => p.x);
            const ys = baseCorners.map(p => p.y);
            extraPoints.forEach(entry => {
                if (!entry || !entry.point) return;
                const shouldRotate = entry.rotate !== false;
                const candidate = shouldRotate
                    ? rotatePointAroundCenter(entry.point, angle, width, height)
                    : { x: entry.point.x, y: entry.point.y };
                xs.push(candidate.x);
                ys.push(candidate.y);
            });
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
        }

        function rotatePointAroundCenter(point, angle, width, height) {
            if (angle === 0) return { x: point.x, y: point.y };
            const cx = width / 2;
            const cy = height / 2;
            const dx = point.x - cx;
            const dy = point.y - cy;
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            return {
                x: cx + dx * cosA - dy * sinA,
                y: cy + dx * sinA + dy * cosA
            };
        }

        function projectPointForPreview(point, transform, rotatePoint = true) {
            if (!point) return { x: 0, y: 0 };
            const source = rotatePoint ?
                rotatePointAroundCenter(point, transform.angle, transform.width, transform.height) :
                { x: point.x, y: point.y };
            const normalizedX = source.x - transform.bounds.minX;
            const normalizedY = source.y - transform.bounds.minY;
            return {
                x: transform.offsetX + normalizedX * transform.scale,
                y: transform.offsetY + normalizedY * transform.scale
            };
        }
        
        // Drawing
        function redraw() {
            const { x: offsetX, y: offsetY, zoom } = getCanvasOffset();
            const grid = parseInt(document.getElementById('gridSize').value);
            const compWidth = parseInt(document.getElementById('compWidth').value) || 80;
            const compHeight = parseInt(document.getElementById('compHeight').value) || 40;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#e8e8e8';
            ctx.lineWidth = 0.25;
            
            const gridZoom = grid * zoom;
            const startX = offsetX % gridZoom;
            const startY = offsetY % gridZoom;
            
            for (let x = startX; x < canvas.width; x += gridZoom) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < canvas.height; y += gridZoom) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw component boundary
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(offsetX, offsetY, compWidth * zoom, compHeight * zoom);
            ctx.setLineDash([]);
            
            // Draw origin marker
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(offsetX, offsetY, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw elements
            elements.forEach((el, idx) => {
                const isSelected = selectedElement === idx || selectedElements.has(idx);
                drawElement(el, isSelected, zoom, offsetX, offsetY);
            });
            
            // Draw pins
            pins.forEach((pin, idx) => {
                const pos = componentToCanvas(pin.position.x, pin.position.y);
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pin.id, pos.x, pos.y);
            });
            
            // Draw polygon in progress
            if (mode === 'polygon' && polygonPoints.length > 0) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const first = componentToCanvas(polygonPoints[0].x, polygonPoints[0].y);
                ctx.moveTo(first.x, first.y);
                polygonPoints.forEach(pt => {
                    const p = componentToCanvas(pt.x, pt.y);
                    ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
            }
            
            // Draw polyline in progress
            if (mode === 'polyline' && polylinePoints.length > 0) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const first = componentToCanvas(polylinePoints[0].x, polylinePoints[0].y);
                ctx.moveTo(first.x, first.y);
                polylinePoints.forEach(pt => {
                    const p = componentToCanvas(pt.x, pt.y);
                    ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
            }
            
            drawArcConstructionPreview();

            // Draw selection rectangle
            if (isSelecting && selectionRect) {
                const start = componentToCanvas(selectionRect.x1, selectionRect.y1);
                const end = componentToCanvas(selectionRect.x2, selectionRect.y2);
                
                ctx.strokeStyle = '#0066ff';
                ctx.fillStyle = 'rgba(0, 102, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.fillRect(start.x, start.y, end.x - start.x, end.y - start.y);
                ctx.strokeRect(start.x, start.y, end.x - start.x, end.y - start.y);
                ctx.setLineDash([]);
            }

            requestLabelPreviewUpdate();
        }
        
        function drawElement(el, isSelected, zoom, offsetX, offsetY) {
            ctx.strokeStyle = isSelected ? '#ff0000' : '#333';
            ctx.fillStyle = el.filled ? (isSelected ? '#ff0000' : '#333') : 'transparent';
            ctx.lineWidth = (el.strokeWidth || 4) * zoom / 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (el.type === 'line') {
                const start = componentToCanvas(el.x1, el.y1);
                const end = componentToCanvas(el.x2, el.y2);
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
            } else if (el.type === 'circle') {
                const center = componentToCanvas(el.cx, el.cy);
                ctx.beginPath();
                ctx.arc(center.x, center.y, el.r * zoom, 0, Math.PI * 2);
                if (el.filled) ctx.fill();
                ctx.stroke();
            } else if (el.type === 'arc') {
                const center = componentToCanvas(el.cx, el.cy);
                ctx.beginPath();
                ctx.arc(center.x, center.y, el.r * zoom, el.startAngle, el.endAngle);
                ctx.stroke();
            } else if (el.type === 'polygon') {
                if (el.points && el.points.length > 0) {
                    ctx.beginPath();
                    const first = componentToCanvas(el.points[0].x, el.points[0].y);
                    ctx.moveTo(first.x, first.y);
                    el.points.forEach(pt => {
                        const p = componentToCanvas(pt.x, pt.y);
                        ctx.lineTo(p.x, p.y);
                    });
                    ctx.closePath();
                    if (el.filled) ctx.fill();
                    ctx.stroke();
                }
            } else if (el.type === 'polyline') {
                if (el.points && el.points.length > 0) {
                    ctx.beginPath();
                    const first = componentToCanvas(el.points[0].x, el.points[0].y);
                    ctx.moveTo(first.x, first.y);
                    el.points.forEach(pt => {
                        const p = componentToCanvas(pt.x, pt.y);
                        ctx.lineTo(p.x, p.y);
                    });
                    // Don't close path for polyline
                    ctx.stroke();
                }
            }
        }

        function drawArcConstructionPreview() {
            if (mode !== 'arc' || arcStage === 0 || !arcCenter) return;
            const { zoom } = getCanvasOffset();
            const centerCanvas = componentToCanvas(arcCenter.x, arcCenter.y);
            ctx.save();
            ctx.strokeStyle = '#0066ff';
            ctx.fillStyle = '#0066ff';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.arc(centerCanvas.x, centerCanvas.y, 3, 0, Math.PI * 2);
            ctx.fill();
            if (arcStage === 1 && arcPreviewPoint) {
                const previewCanvas = componentToCanvas(arcPreviewPoint.x, arcPreviewPoint.y);
                ctx.beginPath();
                ctx.moveTo(centerCanvas.x, centerCanvas.y);
                ctx.lineTo(previewCanvas.x, previewCanvas.y);
                ctx.stroke();
                const radius = Math.sqrt(Math.pow(arcPreviewPoint.x - arcCenter.x, 2) + Math.pow(arcPreviewPoint.y - arcCenter.y, 2));
                if (radius > 0) {
                    ctx.beginPath();
                    ctx.arc(centerCanvas.x, centerCanvas.y, radius * zoom, 0, Math.PI * 2);
                    ctx.stroke();
                }
            } else if (arcStage === 2 && arcRadius) {
                const startPoint = {
                    x: arcCenter.x + Math.cos(arcStartAngle) * arcRadius,
                    y: arcCenter.y + Math.sin(arcStartAngle) * arcRadius
                };
                const startCanvas = componentToCanvas(startPoint.x, startPoint.y);
                ctx.beginPath();
                ctx.moveTo(centerCanvas.x, centerCanvas.y);
                ctx.lineTo(startCanvas.x, startCanvas.y);
                ctx.stroke();
                const endAngle = arcPreviewPoint ? Math.atan2(arcPreviewPoint.y - arcCenter.y, arcPreviewPoint.x - arcCenter.x) : arcStartAngle;
                ctx.beginPath();
                ctx.arc(centerCanvas.x, centerCanvas.y, arcRadius * zoom, arcStartAngle, endAngle);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        // Mouse handlers
        function onMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = (e.clientX - rect.left) * scaleX;
            const cy = (e.clientY - rect.top) * scaleY;
            const shouldSnap = mode !== 'select';
            const pos = canvasToComponent(cx, cy, { snap: shouldSnap });
            
            if (mode === 'select') {
                const pinIndex = findPinNearPosition(pos);
                if (pinIndex !== -1) {
                    draggingPinIndex = pinIndex;
                    const pin = pins[pinIndex];
                    const beforePosition = { x: pin.position.x, y: pin.position.y };
                    pinDragOffset = {
                        x: pin.position.x - pos.x,
                        y: pin.position.y - pos.y
                    };
                    undoStack.push({
                        type: 'move-pin',
                        index: pinIndex,
                        before: beforePosition
                    });
                    return;
                }

                const shiftKey = e.shiftKey;
                
                // First check if clicking on a vertex
                const vertex = findVertexAt(pos.x, pos.y);
                if (vertex) {
                    // Start editing this vertex
                    editingVertex = vertex;
                    selectedElement = vertex.elementIndex;
                    selectedElements.clear();
                    isDragging = true;
                    dragStart = pos;
                    // Save state for undo
                    undoStack.push({
                        type: 'move',
                        index: selectedElement,
                        before: JSON.parse(JSON.stringify(elements[selectedElement]))
                    });
                } else {
                    // Try to select an element or pin
                    const clickedElement = findElementAt(pos.x, pos.y);
                    if (clickedElement !== null) {
                        // Handle multi-selection with shift
                        if (shiftKey) {
                            if (selectedElements.has(clickedElement)) {
                                selectedElements.delete(clickedElement);
                            } else {
                                selectedElements.add(clickedElement);
                            }
                            selectedElement = null;
                        } else {
                            // Single selection - check if clicking on already selected element(s)
                            if (selectedElements.size > 0 && selectedElements.has(clickedElement)) {
                                // Start dragging all selected elements
                                isDragging = true;
                                dragStart = pos;
                                editingVertex = null;
                                // Save original states for all selected elements
                                originalElementStates.clear();
                                selectedElements.forEach(idx => {
                                    originalElementStates.set(idx, JSON.parse(JSON.stringify(elements[idx])));
                                });
                            } else {
                                // New single selection
                                selectedElement = clickedElement;
                                selectedElements.clear();
                                isDragging = true;
                                dragStart = pos;
                                editingVertex = null;
                                // Save original state for dragging and undo
                                originalElementState = JSON.parse(JSON.stringify(elements[selectedElement]));
                                undoStack.push({
                                    type: 'move',
                                    index: selectedElement,
                                    before: originalElementState
                                });
                            }
                        }
                    } else {
                        // Start drag selection if clicking empty space
                        if (!shiftKey) {
                            selectedElement = null;
                            selectedElements.clear();
                        }
                        isSelecting = true;
                        selectionRect = { x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y };
                        editingVertex = null;
                    }
                }
                updateElementList();
                redraw();
            } else if (mode === 'line') {
                isDrawing = true;
                drawStart = pos;
            } else if (mode === 'circle') {
                isDrawing = true;
                drawStart = pos;
            } else if (mode === 'arc') {
                handleArcClick(pos);
            } else if (mode === 'polygon') {
                polygonPoints.push(pos);
                redraw();
            } else if (mode === 'polyline') {
                polylinePoints.push(pos);
                redraw();
            } else if (mode === 'pin') {
                addPin(pos);
            }
        }
        
        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = (e.clientX - rect.left) * scaleX;
            const cy = (e.clientY - rect.top) * scaleY;
            const shouldSnap = mode !== 'select';
            const pos = canvasToComponent(cx, cy, { snap: shouldSnap });
            
            coordIndicator.textContent = `X: ${pos.x.toFixed(2)}, Y: ${pos.y.toFixed(2)}`;

            if (draggingPinIndex !== null) {
                applyPinDragPosition(pos);
                return;
            }

            if (mode === 'arc' && arcStage > 0) {
                arcPreviewPoint = pos;
                redraw();
                return;
            }
            
            if (isSelecting && selectionRect) {
                // Update selection rectangle
                selectionRect.x2 = pos.x;
                selectionRect.y2 = pos.y;
                redraw();
            } else if (isDragging && dragStart) {
                if (editingVertex) {
                    // Edit only the selected vertex
                    const el = elements[editingVertex.elementIndex];
                    const snapToGrid = document.getElementById('snapToGrid').checked;
                    const gridSize = parseInt(document.getElementById('gridSize').value) || 1;
                    const snapValue = (value) => Math.round(value / gridSize) * gridSize;
                    if (el.type === 'line') {
                        if (editingVertex.vertex === 'start') {
                            el.x1 = pos.x;
                            el.y1 = pos.y;
                        } else if (editingVertex.vertex === 'end') {
                            el.x2 = pos.x;
                            el.y2 = pos.y;
                        }
                    } else if (el.type === 'circle') {
                        if (editingVertex.vertex === 'center') {
                            const snappedX = snapToGrid ? snapValue(pos.x) : pos.x;
                            const snappedY = snapToGrid ? snapValue(pos.y) : pos.y;
                            el.cx = snappedX;
                            el.cy = snappedY;
                        } else if (editingVertex.vertex === 'radius') {
                            let handleX = pos.x;
                            let handleY = pos.y;
                            if (snapToGrid) {
                                handleX = snapValue(handleX);
                                handleY = snapValue(handleY);
                            }
                            const radius = Math.sqrt(Math.pow(handleX - el.cx, 2) + Math.pow(handleY - el.cy, 2));
                            el.r = Math.max(1, Math.round(radius));
                        }
                    } else if ((el.type === 'polygon' || el.type === 'polyline') && el.points) {
                        el.points[editingVertex.vertex].x = pos.x;
                        el.points[editingVertex.vertex].y = pos.y;
                    }
                    redraw();
                } else if (selectedElements.size > 0 && originalElementStates.size > 0) {
                    // Drag multiple selected elements
                    const snapToGrid = document.getElementById('snapToGrid').checked;
                    const gridSize = parseInt(document.getElementById('gridSize').value);
                    
                    // Calculate offset from drag start
                    let offsetX = pos.x - dragStart.x;
                    let offsetY = pos.y - dragStart.y;
                    
                    // Snap offset to grid if enabled
                    if (snapToGrid) {
                        offsetX = Math.round(offsetX / gridSize) * gridSize;
                        offsetY = Math.round(offsetY / gridSize) * gridSize;
                    }
                    
                    // Apply offset to all selected elements
                    selectedElements.forEach(idx => {
                        const el = elements[idx];
                        const orig = originalElementStates.get(idx);
                        
                        if (el.type === 'line') {
                            el.x1 = orig.x1 + offsetX;
                            el.y1 = orig.y1 + offsetY;
                            el.x2 = orig.x2 + offsetX;
                            el.y2 = orig.y2 + offsetY;
                        } else if (el.type === 'circle' || el.type === 'arc') {
                            el.cx = orig.cx + offsetX;
                            el.cy = orig.cy + offsetY;
                        } else if ((el.type === 'polygon' || el.type === 'polyline') && el.points) {
                            el.points.forEach((p, i) => {
                                p.x = orig.points[i].x + offsetX;
                                p.y = orig.points[i].y + offsetY;
                            });
                        }
                    });
                    
                    redraw();
                } else if (selectedElement !== null && originalElementState) {
                    // Drag single element - snap the target position to grid
                    const snapToGrid = document.getElementById('snapToGrid').checked;
                    const el = elements[selectedElement];
                    const orig = originalElementState;
                    
                    // Calculate offset from drag start
                    const offsetX = pos.x - dragStart.x;
                    const offsetY = pos.y - dragStart.y;
                    
                    // Calculate where the reference point would be
                    let targetX, targetY;
                    if (el.type === 'line') {
                        targetX = orig.x1 + offsetX;
                        targetY = orig.y1 + offsetY;
                    } else if (el.type === 'circle' || el.type === 'arc') {
                        targetX = orig.cx + offsetX;
                        targetY = orig.cy + offsetY;
                    } else if ((el.type === 'polygon' || el.type === 'polyline') && el.points) {
                        targetX = orig.points[0].x + offsetX;
                        targetY = orig.points[0].y + offsetY;
                    }
                    
                    // Snap target position to grid if enabled
                    if (snapToGrid) {
                        const gridSize = parseInt(document.getElementById('gridSize').value);
                        targetX = Math.round(targetX / gridSize) * gridSize;
                        targetY = Math.round(targetY / gridSize) * gridSize;
                    }
                    
                    // Calculate actual delta to apply (from original to snapped target)
                    let dx, dy;
                    if (el.type === 'line') {
                        dx = targetX - orig.x1;
                        dy = targetY - orig.y1;
                    } else if (el.type === 'circle' || el.type === 'arc') {
                        dx = targetX - orig.cx;
                        dy = targetY - orig.cy;
                    } else if ((el.type === 'polygon' || el.type === 'polyline') && el.points) {
                        dx = targetX - orig.points[0].x;
                        dy = targetY - orig.points[0].y;
                    }
                    
                    // Apply delta to all points
                    if (el.type === 'line') {
                        el.x1 = orig.x1 + dx;
                        el.y1 = orig.y1 + dy;
                        el.x2 = orig.x2 + dx;
                        el.y2 = orig.y2 + dy;
                    } else if (el.type === 'circle' || el.type === 'arc') {
                        el.cx = orig.cx + dx;
                        el.cy = orig.cy + dy;
                    } else if ((el.type === 'polygon' || el.type === 'polyline') && el.points) {
                        el.points.forEach((p, i) => {
                            p.x = orig.points[i].x + dx;
                            p.y = orig.points[i].y + dy;
                        });
                    }
                    
                    redraw();
                }
            } else if (isDrawing && drawStart) {
                redraw();
                
                const { zoom } = getCanvasOffset();
                const start = componentToCanvas(drawStart.x, drawStart.y);
                const end = componentToCanvas(pos.x, pos.y);
                
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                if (mode === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                } else if (mode === 'circle') {
                    const radius = Math.sqrt(Math.pow(pos.x - drawStart.x, 2) + Math.pow(pos.y - drawStart.y, 2));
                    ctx.beginPath();
                    ctx.arc(start.x, start.y, radius * zoom, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
            }
        }
        
        function onMouseUp(e) {
            if (draggingPinIndex !== null) {
                const pin = pins[draggingPinIndex];
                const lastAction = undoStack[undoStack.length - 1];
                if (lastAction && lastAction.type === 'move-pin') {
                    const before = lastAction.before;
                    if (!pin || (pin.position.x === before.x && pin.position.y === before.y)) {
                        undoStack.pop();
                    }
                }
                updatePinList();
                redraw();
                resetPinDragState();
                return;
            }
            if (isSelecting) {
                // Finish selection rectangle
                if (selectionRect) {
                    const minX = Math.min(selectionRect.x1, selectionRect.x2);
                    const maxX = Math.max(selectionRect.x1, selectionRect.x2);
                    const minY = Math.min(selectionRect.y1, selectionRect.y2);
                    const maxY = Math.max(selectionRect.y1, selectionRect.y2);
                    
                    // Find elements within rectangle
                    elements.forEach((el, idx) => {
                        if (isElementInRect(el, minX, minY, maxX, maxY)) {
                            selectedElements.add(idx);
                        }
                    });
                }
                
                isSelecting = false;
                selectionRect = null;
                updateElementList();
                redraw();
                return;
            }
            
            if (isDragging) {
                // Check if element actually moved
                if (selectedElements.size > 0 && originalElementStates.size > 0) {
                    // Save undo for multi-element move
                    const beforeStates = new Map();
                    originalElementStates.forEach((state, idx) => {
                        beforeStates.set(idx, state);
                    });
                    undoStack.push({
                        type: 'multi-move',
                        states: beforeStates,
                        indices: Array.from(selectedElements)
                    });
                    originalElementStates.clear();
                } else if (undoStack.length > 0 && undoStack[undoStack.length - 1].type === 'move') {
                    const lastAction = undoStack[undoStack.length - 1];
                    const current = elements[lastAction.index];
                    const before = lastAction.before;
                    // If no actual change, remove the undo action
                    if (JSON.stringify(current) === JSON.stringify(before)) {
                        undoStack.pop();
                    }
                }
                isDragging = false;
                dragStart = null;
                editingVertex = null;
                originalElementState = null;
                updateElementList();
                redraw();
                return;
            }
            
            if (!isDrawing || !drawStart) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = (e.clientX - rect.left) * scaleX;
            const cy = (e.clientY - rect.top) * scaleY;
            const shouldSnap = mode !== 'select';
            const pos = canvasToComponent(cx, cy, { snap: shouldSnap });
            
            const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
            const filled = document.getElementById('filled').checked;
            
            if (mode === 'line') {
                elements.push({
                    type: 'line',
                    x1: drawStart.x,
                    y1: drawStart.y,
                    x2: pos.x,
                    y2: pos.y,
                    strokeWidth
                });
                undoStack.push({ type: 'create', index: elements.length - 1 });
            } else if (mode === 'circle') {
                const radius = Math.sqrt(Math.pow(pos.x - drawStart.x, 2) + Math.pow(pos.y - drawStart.y, 2));
                elements.push({
                    type: 'circle',
                    cx: drawStart.x,
                    cy: drawStart.y,
                    r: Math.round(radius),
                    strokeWidth,
                    filled
                });
                undoStack.push({ type: 'create', index: elements.length - 1 });
            }
            
            isDrawing = false;
            drawStart = null;
            updateElementList();
            redraw();
        }

        function handleArcClick(pos) {
            if (arcStage === 0) {
                arcCenter = pos;
                arcStage = 1;
            } else if (arcStage === 1) {
                const radius = Math.sqrt(Math.pow(pos.x - arcCenter.x, 2) + Math.pow(pos.y - arcCenter.y, 2));
                if (radius < 1) return;
                arcRadius = radius;
                arcStartAngle = Math.atan2(pos.y - arcCenter.y, pos.x - arcCenter.x);
                arcStage = 2;
                arcPreviewPoint = pos;
            } else if (arcStage === 2) {
                const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
                const endAngle = Math.atan2(pos.y - arcCenter.y, pos.x - arcCenter.x);
                if (Math.abs(endAngle - arcStartAngle) < 0.01) {
                    arcPreviewPoint = pos;
                    redraw();
                    return;
                }
                elements.push({
                    type: 'arc',
                    cx: arcCenter.x,
                    cy: arcCenter.y,
                    r: Math.max(1, Math.round(arcRadius)),
                    startAngle: arcStartAngle,
                    endAngle,
                    strokeWidth
                });
                undoStack.push({ type: 'create', index: elements.length - 1 });
                resetArcConstruction();
                updateElementList();
            }
            redraw();
        }
        
        function onDoubleClick(e) {
            if (mode === 'polygon' && polygonPoints.length >= 3) {
                const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
                const filled = document.getElementById('filled').checked;
                
                elements.push({
                    type: 'polygon',
                    points: [...polygonPoints],
                    strokeWidth,
                    filled
                });
                undoStack.push({ type: 'create', index: elements.length - 1 });
                
                polygonPoints = [];
                updateElementList();
                redraw();
            } else if (mode === 'polyline' && polylinePoints.length >= 2) {
                const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
                
                elements.push({
                    type: 'polyline',
                    points: [...polylinePoints],
                    strokeWidth
                });
                undoStack.push({ type: 'create', index: elements.length - 1 });
                
                polylinePoints = [];
                updateElementList();
                redraw();
            }
        }

        function getHitThreshold(targetPixels = 4, options = {}) {
            const { zoom } = getCanvasOffset();
            const safeZoom = Math.max(zoom, 0.1);
            const minComponentUnits = options.min || 1.5;
            const maxComponentUnits = options.max || 8;
            const converted = targetPixels / safeZoom;
            return Math.max(minComponentUnits, Math.min(maxComponentUnits, converted));
        }
        
        function findElementAt(x, y) {
            const threshold = getHitThreshold(3, { min: 1.5 });
            
            for (let i = elements.length - 1; i >= 0; i--) {
                const el = elements[i];
                
                if (el.type === 'line') {
                    const dist = pointToLineDistance(x, y, el.x1, el.y1, el.x2, el.y2);
                    if (dist < threshold) return i;
                } else if (el.type === 'circle' || el.type === 'arc') {
                    const dist = Math.abs(Math.sqrt(Math.pow(x - el.cx, 2) + Math.pow(y - el.cy, 2)) - el.r);
                    if (dist < threshold) return i;
                } else if (el.type === 'polygon' && el.points) {
                    // Check if point is near any edge of the polygon
                    for (let j = 0; j < el.points.length; j++) {
                        const p1 = el.points[j];
                        const p2 = el.points[(j + 1) % el.points.length];
                        const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist < threshold) return i;
                    }
                } else if (el.type === 'polyline' && el.points) {
                    // Check if point is near any segment of the polyline
                    for (let j = 0; j < el.points.length - 1; j++) {
                        const p1 = el.points[j];
                        const p2 = el.points[j + 1];
                        const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist < threshold) return i;
                    }
                }
            }
            
            return null;
        }
        
        function findVertexAt(x, y) {
            const threshold = getHitThreshold(4, { min: 2 });
            
            for (let i = elements.length - 1; i >= 0; i--) {
                const el = elements[i];
                
                if (el.type === 'line') {
                    // Check start point
                    if (Math.sqrt(Math.pow(x - el.x1, 2) + Math.pow(y - el.y1, 2)) < threshold) {
                        return { elementIndex: i, vertex: 'start' };
                    }
                    // Check end point
                    if (Math.sqrt(Math.pow(x - el.x2, 2) + Math.pow(y - el.y2, 2)) < threshold) {
                        return { elementIndex: i, vertex: 'end' };
                    }
                } else if (el.type === 'polygon' && el.points) {
                    // Check each vertex of polygon
                    for (let j = 0; j < el.points.length; j++) {
                        const p = el.points[j];
                        if (Math.sqrt(Math.pow(x - p.x, 2) + Math.pow(y - p.y, 2)) < threshold) {
                            return { elementIndex: i, vertex: j };
                        }
                    }
                } else if (el.type === 'polyline' && el.points) {
                    // Check each vertex of polyline
                    for (let j = 0; j < el.points.length; j++) {
                        const p = el.points[j];
                        if (Math.sqrt(Math.pow(x - p.x, 2) + Math.pow(y - p.y, 2)) < threshold) {
                            return { elementIndex: i, vertex: j };
                        }
                    }
                } else if (el.type === 'circle') {
                    const distToCenter = Math.sqrt(Math.pow(x - el.cx, 2) + Math.pow(y - el.cy, 2));
                    if (distToCenter < threshold) {
                        return { elementIndex: i, vertex: 'center' };
                    }
                    if (Math.abs(distToCenter - el.r) < threshold) {
                        return { elementIndex: i, vertex: 'radius' };
                    }
                }
            }
            
            return null;
        }
        
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = lenSq !== 0 ? dot / lenSq : -1;
            
            let xx, yy;
            if (param < 0) {
                xx = x1; yy = y1;
            } else if (param > 1) {
                xx = x2; yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            return Math.sqrt(Math.pow(px - xx, 2) + Math.pow(py - yy, 2));
        }
        
        function isElementInRect(el, minX, minY, maxX, maxY) {
            // Check if any part of the element is within the rectangle
            if (el.type === 'line') {
                // Check if either endpoint is in rect, or if line intersects rect
                return (el.x1 >= minX && el.x1 <= maxX && el.y1 >= minY && el.y1 <= maxY) ||
                       (el.x2 >= minX && el.x2 <= maxX && el.y2 >= minY && el.y2 <= maxY);
            } else if (el.type === 'circle' || el.type === 'arc') {
                // Check if center is in rect (simplified)
                return el.cx >= minX && el.cx <= maxX && el.cy >= minY && el.cy <= maxY;
            } else if ((el.type === 'polygon' || el.type === 'polyline') && el.points) {
                // Check if any point is in rect
                return el.points.some(p => p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY);
            }
            return false;
        }

        function findPinNearPosition(pos) {
            if (!pos || !pins.length) return -1;
            const threshold = getHitThreshold(8, { min: 2, max: 12 });
            for (let i = pins.length - 1; i >= 0; i--) {
                const pinPos = pins[i]?.position;
                if (!pinPos) continue;
                const dist = Math.hypot(pinPos.x - pos.x, pinPos.y - pos.y);
                if (dist <= threshold) {
                    return i;
                }
            }
            return -1;
        }

        function applyPinDragPosition(pos) {
            if (draggingPinIndex === null) return;
            const pin = pins[draggingPinIndex];
            if (!pin || !pos) return;
            const gridSize = parseInt(document.getElementById('gridSize').value, 10) || 1;
            const snapToGrid = document.getElementById('snapToGrid').checked;
            let targetX = pos.x + (pinDragOffset?.x || 0);
            let targetY = pos.y + (pinDragOffset?.y || 0);
            if (snapToGrid) {
                targetX = Math.round(targetX / gridSize) * gridSize;
                targetY = Math.round(targetY / gridSize) * gridSize;
            }
            pin.position.x = targetX;
            pin.position.y = targetY;
            updatePinList();
            redraw();
        }

        function resetPinDragState() {
            draggingPinIndex = null;
            pinDragOffset = null;
        }
        
        // Pin management
        function addPin(pos) {
            const id = (pins.length + 1).toString();
            pins.push({
                id,
                name: id,
                position: { x: pos.x, y: pos.y }
            });
            updatePinList();
            redraw();
        }
        
        function addPinManual() {
            const id = (pins.length + 1).toString();
            pins.push({
                id,
                name: id,
                position: { x: 0, y: 0 }
            });
            updatePinList();
            redraw();
        }
        
        function updatePinList() {
            const container = document.getElementById('pinList');
            container.innerHTML = pins.map((pin, idx) => `
                <div class="pin-item">
                    <div class="pin-header">
                        <span>Pin ${pin.id}: ${pin.name}</span>
                        <button class="btn btn-danger small-btn" onclick="removePin(${idx})">×</button>
                    </div>
                    <div class="pin-coords">
                        <input type="text" value="${pin.name}" placeholder="Name" onchange="updatePin(${idx}, 'name', this.value)">
                        <input type="number" value="${pin.position.x}" onchange="updatePin(${idx}, 'x', this.value)">
                        <input type="number" value="${pin.position.y}" onchange="updatePin(${idx}, 'y', this.value)">
                    </div>
                </div>
            `).join('');
        }
        
        function updatePin(idx, prop, value) {
            if (prop === 'name') {
                pins[idx].name = value;
            } else if (prop === 'x') {
                pins[idx].position.x = parseInt(value);
            } else if (prop === 'y') {
                pins[idx].position.y = parseInt(value);
            }
            redraw();
        }
        
        function removePin(idx) {
            pins.splice(idx, 1);
            // Renumber pins
            pins.forEach((p, i) => p.id = (i + 1).toString());
            updatePinList();
            redraw();
        }
        
        // Element list
        function updateElementList() {
            const container = document.getElementById('elementList');
            container.innerHTML = elements.map((el, idx) => {
                const isSelected = selectedElement === idx || selectedElements.has(idx);
                return `
                <div class="element-item ${isSelected ? 'selected' : ''}" onclick="selectElement(${idx}, event)">
                    <div class="element-header">
                        <span>${el.type}</span>
                        <button class="btn btn-danger small-btn" onclick="removeElement(${idx}); event.stopPropagation();">×</button>
                    </div>
                    <div style="font-size: 10px; color: #888;">
                        ${formatElementInfo(el)}
                    </div>
                </div>
            `}).join('');
        }
        
        function formatElementInfo(el) {
            if (el.type === 'line') return `(${el.x1},${el.y1}) → (${el.x2},${el.y2})`;
            if (el.type === 'circle') return `center: (${el.cx},${el.cy}), r: ${el.r}`;
            if (el.type === 'arc') return `center: (${el.cx},${el.cy}), r: ${el.r}`;
            if (el.type === 'polygon') return `${el.points?.length || 0} points (closed)`;
            if (el.type === 'polyline') return `${el.points?.length || 0} points (open)`;
            return '';
        }
        
        function selectElement(idx, event) {
            if (event && event.shiftKey) {
                // Toggle selection with shift
                if (selectedElements.has(idx)) {
                    selectedElements.delete(idx);
                } else {
                    selectedElements.add(idx);
                }
                selectedElement = null;
            } else {
                // Single selection
                selectedElement = idx;
                selectedElements.clear();
            }
            updateElementList();
            redraw();
        }
        
        function removeElement(idx) {
            const element = elements[idx];
            undoStack.push({ type: 'delete', index: idx, element: JSON.parse(JSON.stringify(element)) });
            elements.splice(idx, 1);
            selectedElement = null;
            selectedElements.clear();
            updateElementList();
            redraw();
        }
        
        function deleteSelected() {
            if (selectedElements.size > 0) {
                // Delete multiple selected elements (from highest index to lowest)
                const indices = Array.from(selectedElements).sort((a, b) => b - a);
                indices.forEach(idx => {
                    const element = elements[idx];
                    undoStack.push({ type: 'delete', index: idx, element: JSON.parse(JSON.stringify(element)) });
                    elements.splice(idx, 1);
                });
                selectedElements.clear();
            } else if (selectedElement !== null) {
                removeElement(selectedElement);
            }
            updateElementList();
            redraw();
        }
        
        function updateSelectedStroke() {
            const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
            
            if (selectedElements.size > 0) {
                selectedElements.forEach(idx => {
                    elements[idx].strokeWidth = strokeWidth;
                });
            } else if (selectedElement !== null) {
                elements[selectedElement].strokeWidth = strokeWidth;
            }
            redraw();
        }
        
        function undo() {
            if (undoStack.length === 0) return;
            
            const action = undoStack.pop();
            
            if (action.type === 'create') {
                // Remove the created element
                elements.splice(action.index, 1);
                selectedElement = null;
            } else if (action.type === 'delete') {
                // Restore the deleted element
                elements.splice(action.index, 0, action.element);
            } else if (action.type === 'move') {
                // Restore previous state of element
                elements[action.index] = JSON.parse(JSON.stringify(action.before));
            } else if (action.type === 'multi-move') {
                // Restore previous states of multiple elements
                action.states.forEach((state, idx) => {
                    elements[idx] = JSON.parse(JSON.stringify(state));
                });
            } else if (action.type === 'move-pin') {
                const pin = pins[action.index];
                if (pin && action.before) {
                    pin.position = { x: action.before.x, y: action.before.y };
                }
                updatePinList();
            }
            
            updateElementList();
            redraw();
        }
        
        function clearDrawing() {
            if (confirm('Clear all drawing elements?')) {
                elements = [];
                selectedElement = null;
                selectedElements.clear();
                resetArcConstruction();
                updateElementList();
                redraw();
            }
        }
        
        // Component management
        function getDefaultLabelPositions(width, height) {
            const w = Number.isFinite(width) ? width : 80;
            const h = Number.isFinite(height) ? height : 40;
            return {
                designator: [
                    { x: Math.round(w / 2), y: -12 },
                    { x: -12, y: Math.round(h / 2) }
                ],
                value: [
                    { x: Math.round(w / 2), y: h + 12 },
                    { x: w + 12, y: Math.round(h / 2) }
                ]
            };
        }

        function setLabelInputs(labels, width, height) {
            const defaults = getDefaultLabelPositions(width, height);
            const designator0 = labels?.designator?.[0] || defaults.designator[0];
            const designator90 = labels?.designator?.[1] || defaults.designator[1];
            const value0 = labels?.value?.[0] || defaults.value[0];
            const value90 = labels?.value?.[1] || defaults.value[1];
            const mappings = [
                { id: 'designatorLabel0X', value: designator0.x },
                { id: 'designatorLabel0Y', value: designator0.y },
                { id: 'valueLabel0X', value: value0.x },
                { id: 'valueLabel0Y', value: value0.y },
                { id: 'designatorLabel90X', value: designator90.x },
                { id: 'designatorLabel90Y', value: designator90.y },
                { id: 'valueLabel90X', value: value90.x },
                { id: 'valueLabel90Y', value: value90.y }
            ];
            mappings.forEach(entry => {
                const input = document.getElementById(entry.id);
                if (input) input.value = entry.value;
            });
            requestLabelPreviewUpdate({ immediate: true });
        }

        function readLabelInputs(width, height) {
            const defaults = getDefaultLabelPositions(width, height);
            const getNumber = (id, fallback) => {
                const input = document.getElementById(id);
                if (!input) return fallback;
                const parsed = parseInt(input.value, 10);
                return Number.isFinite(parsed) ? parsed : fallback;
            };
            return {
                designator: [
                    {
                        x: getNumber('designatorLabel0X', defaults.designator[0].x),
                        y: getNumber('designatorLabel0Y', defaults.designator[0].y)
                    },
                    {
                        x: getNumber('designatorLabel90X', defaults.designator[1].x),
                        y: getNumber('designatorLabel90Y', defaults.designator[1].y)
                    }
                ],
                value: [
                    {
                        x: getNumber('valueLabel0X', defaults.value[0].x),
                        y: getNumber('valueLabel0Y', defaults.value[0].y)
                    },
                    {
                        x: getNumber('valueLabel90X', defaults.value[1].x),
                        y: getNumber('valueLabel90Y', defaults.value[1].y)
                    }
                ]
            };
        }

        // Component management
        function updateComponentList() {
            const container = document.getElementById('componentList');
            container.innerHTML = Object.entries(components).map(([id, comp]) => `
                <div class="component-item ${currentComponentId === id ? 'selected' : ''}" onclick="loadComponent('${id}')">
                    ${comp.svg || '<svg></svg>'}
                    <span>${comp.name}</span>
                </div>
            `).join('');
        }
        
        function loadComponent(id) {
            currentComponentId = id;
            const comp = components[id];
            const compWidthValue = comp.size?.width || 80;
            const compHeightValue = comp.size?.height || 40;
            
            document.getElementById('compId').value = id;
            document.getElementById('compName').value = comp.name || '';
            document.getElementById('compPrefix').value = comp.designator?.prefix || '';
            document.getElementById('compAutoInc').checked = comp.designator?.autoIncrement !== false;
            document.getElementById('compDefault').value = comp.defaultValue || '';
            document.getElementById('compWidth').value = compWidthValue;
            document.getElementById('compHeight').value = compHeightValue;
            document.getElementById('modelName').value = comp.model?.name || '';
            document.getElementById('modelDef').value = comp.model?.definition || '';
            
            pins = comp.pins ? JSON.parse(JSON.stringify(comp.pins)) : [];
            elements = parseSVGToElements(comp.svg);
            setLabelInputs(comp.labels, compWidthValue, compHeightValue);
            selectedElement = null;
            selectedElements.clear();
            resetArcConstruction();
            
            updateComponentList();
            updatePinList();
            updateElementList();
            resizeCanvas(); // Ensure canvas dimensions are recalculated
        }
        
        function parseSVGToElements(svgString) {
            if (!svgString) return [];
            
            const elements = [];
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, 'image/svg+xml');
            const svg = doc.querySelector('svg');
            if (!svg) return [];
            
            // Get viewBox to understand coordinate space
            const viewBox = svg.getAttribute('viewBox');
            let vbWidth = 120, vbHeight = 40;
            if (viewBox) {
                const parts = viewBox.split(/\s+/);
                vbWidth = parseFloat(parts[2]) || 120;
                vbHeight = parseFloat(parts[3]) || 40;
            }
            
            // Scale factor (we'll scale to match component size)
            const compWidth = parseInt(document.getElementById('compWidth').value) || 80;
            const compHeight = parseInt(document.getElementById('compHeight').value) || 40;
            const scaleX = compWidth / vbWidth;
            const scaleY = compHeight / vbHeight;
            const scale = Math.min(scaleX, scaleY);
            
            // Parse paths
            svg.querySelectorAll('path').forEach(path => {
                const d = path.getAttribute('d');
                if (!d) return;
                const strokeWidth = parseFloat(path.getAttribute('stroke-width')) || 4;
                if (path.getAttribute('data-arc') === 'true') {
                    const cx = Math.round(((parseFloat(path.getAttribute('data-cx')) || 0) * scale));
                    const cy = Math.round(((parseFloat(path.getAttribute('data-cy')) || 0) * scale));
                    const r = Math.max(1, Math.round(((parseFloat(path.getAttribute('data-r')) || 0) * scale)));
                    const startAngle = parseFloat(path.getAttribute('data-start')) || 0;
                    const endAngle = parseFloat(path.getAttribute('data-end')) || 0;
                    elements.push({
                        type: 'arc',
                        cx,
                        cy,
                        r,
                        startAngle,
                        endAngle,
                        strokeWidth: strokeWidth * scale
                    });
                    return;
                }
                const lines = parsePathToLines(d, scale);
                lines.forEach(line => {
                    elements.push({ ...line, strokeWidth: strokeWidth * scale });
                });
            });
            
            // Parse circles
            svg.querySelectorAll('circle').forEach(circle => {
                const cx = (parseFloat(circle.getAttribute('cx')) || 0) * scale;
                const cy = (parseFloat(circle.getAttribute('cy')) || 0) * scale;
                const r = (parseFloat(circle.getAttribute('r')) || 0) * scale;
                const strokeWidth = parseFloat(circle.getAttribute('stroke-width')) || 4;
                elements.push({
                    type: 'circle',
                    cx: Math.round(cx),
                    cy: Math.round(cy),
                    r: Math.round(r),
                    strokeWidth: strokeWidth * scale,
                    filled: circle.getAttribute('fill') !== 'none'
                });
            });
            
            // Parse ellipses (convert to circles using average of rx and ry)
            svg.querySelectorAll('ellipse').forEach(ellipse => {
                const cx = (parseFloat(ellipse.getAttribute('cx')) || 0) * scale;
                const cy = (parseFloat(ellipse.getAttribute('cy')) || 0) * scale;
                const rx = (parseFloat(ellipse.getAttribute('rx')) || 0) * scale;
                const ry = (parseFloat(ellipse.getAttribute('ry')) || 0) * scale;
                const r = (rx + ry) / 2; // Average radius
                const strokeWidth = parseFloat(ellipse.getAttribute('stroke-width')) || 4;
                elements.push({
                    type: 'circle',
                    cx: Math.round(cx),
                    cy: Math.round(cy),
                    r: Math.round(r),
                    strokeWidth: strokeWidth * scale,
                    filled: ellipse.getAttribute('fill') !== 'none'
                });
            });
            
            // Parse polygons
            svg.querySelectorAll('polygon').forEach(poly => {
                const pointsStr = poly.getAttribute('points');
                if (pointsStr) {
                    const points = pointsStr.trim().split(/\s+/).map(p => {
                        const [x, y] = p.split(',').map(Number);
                        return { x: Math.round(x * scale), y: Math.round(y * scale) };
                    });
                    const strokeWidth = parseFloat(poly.getAttribute('stroke-width')) || 4;
                    elements.push({
                        type: 'polygon',
                        points,
                        strokeWidth: strokeWidth * scale,
                        filled: poly.getAttribute('fill') !== 'none'
                    });
                }
            });
            
            // Parse polylines
            svg.querySelectorAll('polyline').forEach(poly => {
                const pointsStr = poly.getAttribute('points');
                if (pointsStr) {
                    const points = pointsStr.trim().split(/\s+/).map(p => {
                        const [x, y] = p.split(',').map(Number);
                        return { x: Math.round(x * scale), y: Math.round(y * scale) };
                    });
                    const strokeWidth = parseFloat(poly.getAttribute('stroke-width')) || 4;
                    elements.push({
                        type: 'polyline',
                        points,
                        strokeWidth: strokeWidth * scale
                    });
                }
            });
            
            return elements;
        }
        
        function parsePathToLines(d, scale) {
            const lines = [];
            const commands = d.match(/[MLQCZmlqcz][^MLQCZmlqcz]*/gi) || [];
            
            let currentX = 0, currentY = 0;
            let startX = 0, startY = 0;
            
            commands.forEach(cmd => {
                const type = cmd[0];
                const args = cmd.slice(1).trim().split(/[\s,]+/).map(Number).filter(n => !isNaN(n));
                
                if (type === 'M' || type === 'm') {
                    if (type === 'M') {
                        currentX = args[0];
                        currentY = args[1];
                    } else {
                        currentX += args[0];
                        currentY += args[1];
                    }
                    startX = currentX;
                    startY = currentY;
                } else if (type === 'L' || type === 'l') {
                    for (let i = 0; i < args.length; i += 2) {
                        let newX, newY;
                        if (type === 'L') {
                            newX = args[i];
                            newY = args[i + 1];
                        } else {
                            newX = currentX + args[i];
                            newY = currentY + args[i + 1];
                        }
                        lines.push({
                            type: 'line',
                            x1: Math.round(currentX * scale),
                            y1: Math.round(currentY * scale),
                            x2: Math.round(newX * scale),
                            y2: Math.round(newY * scale)
                        });
                        currentX = newX;
                        currentY = newY;
                    }
                } else if (type === 'Z' || type === 'z') {
                    lines.push({
                        type: 'line',
                        x1: Math.round(currentX * scale),
                        y1: Math.round(currentY * scale),
                        x2: Math.round(startX * scale),
                        y2: Math.round(startY * scale)
                    });
                    currentX = startX;
                    currentY = startY;
                } else if (type === 'Q' || type === 'q') {
                    // Quadratic bezier - approximate with lines
                    for (let i = 0; i < args.length; i += 4) {
                        let cx, cy, ex, ey;
                        if (type === 'Q') {
                            cx = args[i]; cy = args[i + 1];
                            ex = args[i + 2]; ey = args[i + 3];
                        } else {
                            cx = currentX + args[i]; cy = currentY + args[i + 1];
                            ex = currentX + args[i + 2]; ey = currentY + args[i + 3];
                        }
                        // Approximate with line to endpoint
                        lines.push({
                            type: 'line',
                            x1: Math.round(currentX * scale),
                            y1: Math.round(currentY * scale),
                            x2: Math.round(ex * scale),
                            y2: Math.round(ey * scale)
                        });
                        currentX = ex;
                        currentY = ey;
                    }
                }
            });
            
            return lines;
        }
        
        function elementsToSVG() {
            const compWidth = parseInt(document.getElementById('compWidth').value) || 80;
            const compHeight = parseInt(document.getElementById('compHeight').value) || 40;
            
            // Use 1.5x viewBox for typical lead lines
            const vbWidth = Math.round(compWidth * 1.5);
            const vbHeight = Math.round(compHeight * 1.5);
            const offsetX = Math.round((vbWidth - compWidth) / 2);
            const offsetY = Math.round((vbHeight - compHeight) / 2);
            
            const svgParts = [];
            
            elements.forEach(el => {
                const strokeWidth = el.strokeWidth || 4;
                if (el.type === 'line') {
                    const d = `M ${el.x1 + offsetX} ${el.y1 + offsetY} L ${el.x2 + offsetX} ${el.y2 + offsetY}`;
                    svgParts.push(`<path fill="none" stroke="#000000" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round" d="${d}"/>`);
                } else if (el.type === 'circle') {
                    svgParts.push(`<circle cx="${el.cx + offsetX}" cy="${el.cy + offsetY}" r="${el.r}" fill="${el.filled ? '#000000' : 'none'}" stroke="#000000" stroke-width="${strokeWidth}"/>`);
                } else if (el.type === 'arc') {
                    const startX = el.cx + Math.cos(el.startAngle) * el.r;
                    const startY = el.cy + Math.sin(el.startAngle) * el.r;
                    const endX = el.cx + Math.cos(el.endAngle) * el.r;
                    const endY = el.cy + Math.sin(el.endAngle) * el.r;
                    let delta = el.endAngle - el.startAngle;
                    while (delta <= -Math.PI * 2) delta += Math.PI * 2;
                    while (delta >= Math.PI * 2) delta -= Math.PI * 2;
                    const largeArcFlag = Math.abs(delta) > Math.PI ? 1 : 0;
                    const sweepFlag = delta >= 0 ? 1 : 0;
                    const d = `M ${startX + offsetX} ${startY + offsetY} A ${el.r} ${el.r} 0 ${largeArcFlag} ${sweepFlag} ${endX + offsetX} ${endY + offsetY}`;
                    svgParts.push(`<path data-arc="true" data-cx="${el.cx}" data-cy="${el.cy}" data-r="${el.r}" data-start="${el.startAngle}" data-end="${el.endAngle}" fill="none" stroke="#000000" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round" d="${d}"/>`);
                } else if (el.type === 'polygon' && el.points) {
                    const pts = el.points.map(p => `${p.x + offsetX},${p.y + offsetY}`).join(' ');
                    svgParts.push(`<polygon points="${pts}" fill="${el.filled ? '#000000' : 'none'}" stroke="#000000" stroke-width="${strokeWidth}" stroke-linejoin="round"/>`);
                } else if (el.type === 'polyline' && el.points) {
                    const pts = el.points.map(p => `${p.x + offsetX},${p.y + offsetY}`).join(' ');
                    svgParts.push(`<polyline points="${pts}" fill="none" stroke="#000000" stroke-width="${strokeWidth}" stroke-linecap="round" stroke-linejoin="round"/>`);
                }
            });
            
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${vbWidth} ${vbHeight}">${svgParts.join('')}</svg>`;
        }
        
        function updateComponent() {
            const id = document.getElementById('compId').value.trim();
            if (!id) {
                alert('Please enter a component ID');
                return;
            }
            
            const compWidth = parseInt(document.getElementById('compWidth').value) || 80;
            const compHeight = parseInt(document.getElementById('compHeight').value) || 40;
            const labels = readLabelInputs(compWidth, compHeight);
            
            const comp = {
                name: document.getElementById('compName').value || id,
                description: components[currentComponentId]?.description || '',
                defaultValue: document.getElementById('compDefault').value,
                designator: {
                    prefix: document.getElementById('compPrefix').value || id[0].toUpperCase(),
                    autoIncrement: document.getElementById('compAutoInc').checked
                },
                size: {
                    width: compWidth,
                    height: compHeight
                },
                pins: pins.map(p => ({
                    id: p.id,
                    name: p.name,
                    position: { x: p.position.x, y: p.position.y }
                })),
                labels,
                svg: elementsToSVG()
            };
            
            // Add model if specified
            const modelName = document.getElementById('modelName').value.trim();
            const modelDef = document.getElementById('modelDef').value.trim();
            if (modelName && modelDef) {
                comp.model = { name: modelName, definition: modelDef };
            }
            
            // Preserve special flags
            if (components[currentComponentId]?.isGround) {
                comp.isGround = true;
            }
            
            // If ID changed, remove old and add new
            if (currentComponentId && currentComponentId !== id) {
                delete components[currentComponentId];
            }
            
            components[id] = comp;
            currentComponentId = id;
            
            updateComponentList();
            updateJSON();
        }
        
        function newComponent() {
            currentComponentId = null;
            elements = [];
            pins = [];
            selectedElement = null;
            resetArcConstruction();
            
            document.getElementById('compId').value = '';
            document.getElementById('compName').value = '';
            document.getElementById('compPrefix').value = '';
            document.getElementById('compAutoInc').checked = true;
            document.getElementById('compDefault').value = '';
            document.getElementById('compWidth').value = '80';
            document.getElementById('compHeight').value = '40';
            document.getElementById('modelName').value = '';
            document.getElementById('modelDef').value = '';
            const defaultWidth = parseInt(document.getElementById('compWidth').value, 10) || 80;
            const defaultHeight = parseInt(document.getElementById('compHeight').value, 10) || 40;
            setLabelInputs(getDefaultLabelPositions(defaultWidth, defaultHeight), defaultWidth, defaultHeight);
            
            updateComponentList();
            updatePinList();
            updateElementList();
            resizeCanvas(); // Ensure canvas is properly sized
            
            // Focus on the ID field to show something happened
            document.getElementById('compId').focus();
        }
        
        function duplicateComponent() {
            if (!currentComponentId) return;
            
            const newId = currentComponentId + '_copy';
            components[newId] = JSON.parse(JSON.stringify(components[currentComponentId]));
            components[newId].name += ' (Copy)';
            
            currentComponentId = newId;
            document.getElementById('compId').value = newId;
            
            updateComponentList();
            updateJSON();
        }
        
        function deleteComponent() {
            if (!currentComponentId) return;
            if (!confirm(`Delete component "${currentComponentId}"?`)) return;
            
            delete components[currentComponentId];
            currentComponentId = null;
            newComponent();
            updateJSON();
        }
        
        // JSON handling
        function updateJSON() {
            document.getElementById('jsonOutput').value = JSON.stringify(components, null, '\t');
        }
        
        function copyJSON() {
            const output = document.getElementById('jsonOutput');
            output.select();
            document.execCommand('copy');
            alert('JSON copied to clipboard!');
        }
        
        function loadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    components = JSON.parse(e.target.result);
                    currentComponentId = null;
                    newComponent();
                    updateComponentList();
                    updateJSON();
                    alert('Components loaded successfully!');
                } catch (err) {
                    alert('Error parsing JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        // Initialize
        init();
        setMode('select');
    </script>
</body>
</html>